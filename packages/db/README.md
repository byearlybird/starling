# @byearlybird/starling-db

Database utilities for Starling.

## Purpose

This package builds on the `@byearlybird/starling` core primitives to provide:

- Typed collections backed by schemas
- CRUD operations and snapshot-based merging
- Transactions with snapshot isolation
- Batched mutation events at collection and database level

It does **not** currently provide the higher-level Store + plugin API that existed in earlier versions of Starling. That layer will be rebuilt on top of this package in a future iteration.

## Core Ideas

At a high level:

- You describe your data model with schemas.
- `createDatabase` builds collections from those schemas.
- Each collection exposes simple CRUD + merge operations.
- Transactions execute against a copy-on-write view and commit as a batch, emitting a single mutation event per collection.

All of this is implemented in terms of Starlingâ€™s CRDT primitives (`createMap`, `mergeDocuments`, and hybrid logical clocks).

## Installation

```bash
bun add @byearlybird/starling @byearlybird/starling-db zod
```

## Defining a Database

`@byearlybird/starling-db` expects schemas that implement the Standard Schema v1 interface (`StandardSchemaV1`). Popular validation libraries such as **Zod**, **Valibot**, and **ArkType** already implement this interface, so you can pass their schemas directly. A database groups one or more collections.

```ts
import { z } from "zod";
import { createDatabase, type DbConfig } from "@byearlybird/starling-db";

// Define your schema (Zod implements Standard Schema v1)
const taskSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  completed: z.boolean().default(false),
});

type Task = z.infer<typeof taskSchema>;

const db = createDatabase({
  name: "my-app",
  schema: {
    tasks: {
      schema: taskSchema,
      getId: (task) => task.id,
    },
  },
});
```

The resulting `db` has a `tasks` collection handle with typed methods.

## Collections

Each collection handle supports CRUD operations, queries by predicate, and merging from a snapshot:

```ts
// Add
const task = db.tasks.add({ id: "1", title: "Learn Starling" });

// Update
db.tasks.update("1", { completed: true });

// Remove (soft delete at the CRDT level)
db.tasks.remove("1");

// Read
const single = db.tasks.get("1");
const allActive = db.tasks.getAll();

// Filtered view
const importantTitles = db.tasks.find(
  (t) => !t.completed,
  {
    map: (t) => t.title,
    sort: (a, b) => a.localeCompare(b),
  },
);
```

Collections can also merge a `JsonDocument` generated by another replica or loaded from storage:

```ts
import type { JsonDocument } from "@byearlybird/starling";

declare const remoteDoc: JsonDocument<Task>;

db.tasks.merge(remoteDoc);
```

Schema validation runs on writes and merges, so invalid data is rejected early.

## Transactions

Use `begin` to run a transaction with snapshot isolation. Internally, collections are cloned lazily (copy-on-write). All writes in a transaction are batched into a single mutation event per affected collection.

```ts
db.begin((tx) => {
  tx.tasks.add({ id: "2", title: "Write docs", completed: false });
  tx.tasks.update("1", { completed: false });
});
```

If you need to cancel a transaction, call `tx.rollback()` inside the callback. Any thrown error also prevents commits.

## Mutation Events

Both collections and the database emit mutation events describing batched changes.

```ts
// Collection-level events
const unsubscribeTasks = db.tasks.on("mutation", (mutation) => {
  for (const added of mutation.added) {
    console.log("Task added:", added.id, added.item);
  }
});

// Database-level events
const unsubscribeDb = db.on("mutation", (events) => {
  for (const { collection, added, updated, removed } of events) {
    console.log(`[${String(collection)}] added=${added.length} updated=${updated.length} removed=${removed.length}`);
  }
});
```

During a transaction, all mutations in that transaction are batched into a single event per collection when the transaction commits.

## Plugins

Plugins extend the database with custom lifecycle hooks for persistence, synchronization, logging, and other cross-cutting concerns.

### Plugin Structure

A plugin is an object with optional `init` and `dispose` handlers:

```ts
import type { DatabasePlugin } from "@byearlybird/starling-db";

const myPlugin: DatabasePlugin<{ tasks: typeof taskSchema }> = {
  handlers: {
    init: async (db) => {
      // Called when db.init() is invoked
      // Load data, establish connections, subscribe to events, etc.
    },
    dispose: async (db) => {
      // Called when db.dispose() is invoked
      // Save data, close connections, clean up resources, etc.
    },
  },
};
```

Both handlers receive the full database instance and can be sync or async.

### Using Plugins

Register plugins when creating the database:

```ts
const db = createDatabase({
  name: "my-app",
  schema: {
    tasks: { schema: taskSchema, getId: (task) => task.id },
  },
}).use(idbPlugin).use(httpPlugin);

// Initialize the database (runs all plugin init handlers)
await db.init();

// Use the database
db.tasks.add({ id: "1", title: "Learn Starling", completed: false });

// Clean up (runs all plugin dispose handlers)
await db.dispose();
```

### Execution Order

- **Init handlers** run in registration order: `[plugin1, plugin2, plugin3]`
- **Dispose handlers** run in reverse order (LIFO): `[plugin3, plugin2, plugin1]`

This ensures proper cleanup when plugins depend on each other.

### Plugin Capabilities

Plugins have full access to the database instance:

- **Collections**: Read, write, merge data via collection handles
- **Events**: Subscribe to mutation events with `db.on("mutation", ...)`
- **Transactions**: Run multi-collection operations with `db.begin(...)`
- **Export**: Get snapshots for all collections with `db.toDocuments()`

### Example: IndexedDB Persistence

```ts
const idbPlugin: DatabasePlugin<{ tasks: typeof taskSchema }> = {
  handlers: {
    init: async (db) => {
      // Load persisted data
      const saved = await loadFromIndexedDB();
      if (saved.tasks) {
        db.tasks.merge(saved.tasks);
      }

      // Subscribe to changes and persist on mutation
      db.on("mutation", async () => {
        const docs = db.toDocuments();
        await saveToIndexedDB(docs);
      });
    },
    dispose: async (db) => {
      // Final save on cleanup
      const docs = db.toDocuments();
      await saveToIndexedDB(docs);
    },
  },
};
```

### Example: HTTP Sync

```ts
const httpPlugin: DatabasePlugin<{ tasks: typeof taskSchema }> = {
  handlers: {
    init: async (db) => {
      // Fetch initial data
      const response = await fetch("https://api.example.com/sync");
      const data = await response.json();
      if (data.tasks) {
        db.tasks.merge(data.tasks);
      }

      // Poll for updates every 5 seconds
      const interval = setInterval(async () => {
        const response = await fetch("https://api.example.com/sync");
        const data = await response.json();
        if (data.tasks) {
          db.tasks.merge(data.tasks);
        }
      }, 5000);

      // Store interval ID for cleanup
      (httpPlugin as any)._interval = interval;
    },
    dispose: async (db) => {
      // Clear polling interval
      clearInterval((httpPlugin as any)._interval);

      // Push final state to server
      const docs = db.toDocuments();
      await fetch("https://api.example.com/sync", {
        method: "POST",
        body: JSON.stringify(docs),
      });
    },
  },
};
```

### Lifecycle Methods

The database exposes two async methods for plugin lifecycle:

- `db.init(): Promise<void>` - Execute all plugin init handlers
- `db.dispose(): Promise<void>` - Execute all plugin dispose handlers

These are the **only async methods** on the database. All CRUD operations remain synchronous.

## Development Status

This package is early but functional:

- Collections, transactions, and mutation events are implemented and tested.
- Plugin system with init/dispose lifecycle hooks is implemented and tested.
- Schema integration is intentionally minimal to keep the API small.

Planned (not implemented here yet):

- A higher-level Store API built on `createDatabase`
- Query helpers for common patterns
- Built-in persistence and sync plugins

## License

MIT
