# @byearlybird/starling-db

Database utilities for Starling.

## Purpose

This package builds on the `@byearlybird/starling` core primitives to provide:

- Typed collections backed by schemas
- CRUD operations and snapshot-based merging
- Transactions with snapshot isolation
- Batched mutation events at collection and database level

It does **not** currently provide the higher-level Store + plugin API that existed in earlier versions of Starling. That layer will be rebuilt on top of this package in a future iteration.

## Core Ideas

At a high level:

- You describe your data model with schemas.
- `createDatabase` builds collections from those schemas.
- Each collection exposes simple CRUD + merge operations.
- Transactions execute against a copy-on-write view and commit as a batch, emitting a single mutation event per collection.

All of this is implemented in terms of Starlingâ€™s CRDT primitives (`createMap`, `mergeDocuments`, and hybrid logical clocks).

## Installation

```bash
bun add @byearlybird/starling @byearlybird/starling-db zod
```

## Defining a Database

`@byearlybird/starling-db` expects schemas that implement the Standard Schema v1 interface (`StandardSchemaV1`). Popular validation libraries such as **Zod**, **Valibot**, and **ArkType** already implement this interface, so you can pass their schemas directly. A database groups one or more collections.

```ts
import { z } from "zod";
import { createDatabase, type DbConfig } from "@byearlybird/starling-db";

// Define your schema (Zod implements Standard Schema v1)
const taskSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  completed: z.boolean().default(false),
});

type Task = z.infer<typeof taskSchema>;

const config: DbConfig<{ tasks: typeof taskSchema }> = {
  schema: {
    tasks: {
      schema: taskSchema,
      getId: (task) => task.id,
    },
  },
};

const db = createDatabase(config);
```

The resulting `db` has a `tasks` collection handle with typed methods.

## Collections

Each collection handle supports CRUD operations, queries by predicate, and merging from a snapshot:

```ts
// Add
const task = db.tasks.add({ id: "1", title: "Learn Starling" });

// Update
db.tasks.update("1", { completed: true });

// Remove (soft delete at the CRDT level)
db.tasks.remove("1");

// Read
const single = db.tasks.get("1");
const allActive = db.tasks.getAll();

// Filtered view
const importantTitles = db.tasks.find(
  (t) => !t.completed,
  {
    map: (t) => t.title,
    sort: (a, b) => a.localeCompare(b),
  },
);
```

Collections can also merge a `JsonDocument` generated by another replica or loaded from storage:

```ts
import type { JsonDocument } from "@byearlybird/starling";

declare const remoteDoc: JsonDocument<Task>;

db.tasks.merge(remoteDoc);
```

Schema validation runs on writes and merges, so invalid data is rejected early.

## Transactions

Use `begin` to run a transaction with snapshot isolation. Internally, collections are cloned lazily (copy-on-write). All writes in a transaction are batched into a single mutation event per affected collection.

```ts
db.begin((tx) => {
  tx.tasks.add({ id: "2", title: "Write docs", completed: false });
  tx.tasks.update("1", { completed: false });
});
```

If you need to cancel a transaction, call `tx.rollback()` inside the callback. Any thrown error also prevents commits.

## Mutation Events

Both collections and the database emit mutation events describing batched changes.

```ts
// Collection-level events
const unsubscribeTasks = db.tasks.on("mutation", (mutation) => {
  for (const added of mutation.added) {
    console.log("Task added:", added.id, added.item);
  }
});

// Database-level events
const unsubscribeDb = db.on("mutation", (events) => {
  for (const { collection, added, updated, removed } of events) {
    console.log(`[${String(collection)}] added=${added.length} updated=${updated.length} removed=${removed.length}`);
  }
});
```

During a transaction, all mutations in that transaction are batched into a single event per collection when the transaction commits.

## Development Status

This package is early but functional:

- Collections, transactions, and mutation events are implemented and tested.
- Schema integration is intentionally minimal to keep the API small.

Planned (not implemented here yet):

- A higher-level Store API built on `createDatabase`
- Query helpers for common patterns
- Persistence adapters and integration guides

## License

MIT
